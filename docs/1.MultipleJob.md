### Spring Batch 5 변경사항
Spring Batch 5 이후로는 `spring.batch.job.names` 옵션을 지원하지 않는다. <br>
추가로 한 어플리케이션 내에서 여러개의 job을 지정할 경우 원하는 job을 실행할 수 있도록 환경을 구성했다. <br>

**0. application.properties**<br>
```java
spring.batch.job.name=${job.name:NONE}
spring.batch.jdbc.initialize-schema=always
spring.batch.job.enabled=true
```
이렇게 구성하면 입력받은 job.name을 이용해서 곧바로 실행시킬 수 있다. <br>

**1.Job 구성** <br>
간단하게 itemReader, Processor, Writer가 필요하지 않은 환경을 구성했다. <br>
그래서 tasklet을 사용했고, 각각의 Job-Step은 아래와 같은 형식으로 구성했다. <br>
```java
@Bean
public Job helloWorldJob(Step helloWorldStep) {
    return new JobBuilder("helloJob", jobRepository)
            .start(helloWorldStep)
            .build();
}


@Bean
public Step helloWorldStep(Tasklet helloWorldTasklet) {
    return new StepBuilder("helloStep", jobRepository)
            .tasklet(helloWorldTasklet, transactionManager)
            .build();
}

@Bean
@StepScope
public Tasklet helloWorldTasklet(@Value("#{jobParameters[name1]}") String name) {
    return (contribution, chunkContext) -> {
        System.out.println("Hello, " + (name != null ? name : "World") + "!");
        return RepeatStatus.FINISHED;
    };
}
```
물론 chunkContext를 이용해서 JobParameter를 받아오는 방법도 있다.<br>
그러나 Scope를 명시하고 JobParameter를 사용할 경우 Late Binding을 사용할 수 있기에 초반 서버 부팅시 성능상 이점을 가져갈 수 있고, Bean 등록 순서에 의한 오류 발생 가능성도 현저히 낮아진다. <br>

**2.실행 파라미터** <br>
```shell
--job.name=${job name} ${job parameter name}=${job parameter value}
```
